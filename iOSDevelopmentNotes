***What's in iOS

-Cocoa Touch --Alerts, buttons, sliders, camera, map kit, web view.
-Media --For images, video, audio, openGL
-Core Services --Frameworks
-Core OS --Kernel etc

***Platform Components
Tools --XCode
Language --Swift, Objective C
Frameworks --Foundation, Core Data, UIKit,Core Motion, Map Kit
Design Strategy --MVC

Demo for Calculator:

Optional: Not Set(nil) OR Something(With some type)
It cant be a String with can be nil but an Optional which can be String.

***MVC
Model: What your application is (not hoe it is displayed)
Controler: How the Model is to be displayed in the UI
View: The controller's minions

Controller ->Model, View are allowed
Model to View ->Never
View to Controller -> Restricted  Way..like an action,delegate,protocol(will,should,did), data source 
Model to Controller -> Notification & KVO. Broadcasts information.

Multiple MVCs can be working together.



Structs cant have inheritance and they are passed by value not reference.

Lecture -4 
***Optional

enum Optional<T>{
	case None
	case Some(T)
}

let x: String? = nil ==>> let x = Optional<String>.None
let x: String? = "hello" ==>> let x = Optional<String>.Some("hello")

var y=x! ==>> switch x {
	case Some(let value): y = value
	case None: //exception
}

***Array
var a = Array<String>()
var a = [String]()

let arrays cant be mutated.
array index out of bound.

for ... in to loop through values


***Dictionaries
var a = Dictionary<String,Int>()
var a = [String:Int]()

a = ["Stan":1,"Cal":10]
Returns an optional 

for (key,value) in a {
	
}

***Range
Just two end points of a sensible type
It is generic
struct Range<T>{
	var startIndex:T
	var endIndex:T
}

let a = ["a","b","c","d"]

let subarray = a[2...3] //["c","d"]
let subarray2= a[2..<3] //["c"]

for i in [27...104] {}// enumerable

***NSObject
Base of all Objective C classes

***NSNumber
Number holding class
let n = NSNumber(35.5)
let val = n.intValue

***NSDate
For dates. NSCalendar,NSDateFormatter,NSDateComponents

***NSData
Bag of bits

***DS in Swift
Classes, Struct, and Enum
-Decalaration Syntax
-Properties and functions
-Initializers

Difference:
-Inheritance (Classes only)
-Introspection and casting(class only)
-Value type(struct,enum) vs Reference type(class)

***Value vs refrence
-Value types are copied when passed to methods or assigned.
-Var is mutable , let is not 
-mutating keyword

-Reference(class)
-Stored in heap
-Constant pointers to a class


***Method

-Override
-final(cant be over ridden). Can mark the enitre class final
-Instances and types can have methods
-static and instance methods concept

-Parameter Name: internal name and external name
eg: func foo(external internal: Int){
	let local = internal
}
func bar(){
	let result = foo(external:123)
}
_ if you dont want external names
# force external names to be the same as internal for the first
for others, internal names are by default the external names

First param should be obvious, second you have to tell others.

***Properties
-Property Observers: cna observe change to properties

var someProp : Int = 42 {
	willSet{newValue is the new new value}
	didSet{oldValue is the old value}
}

Can be done on inherited prop also
-Used to update ui for example

-Lazy Initialization: Does not get initialized unless someone accesses it.

lazy var brain = CalculatorBrain()

lazy var someProp:Type = {
	return <constrcuted value>
}()

lazy var myProp = self.initializeMyProperty()
Only vars can be lazy initialized not let.

***Initialization
-When needed?  
--Free Inits: When all properties in a base class have defaults, you get init() for free
--If a struct has no initializers, it will have a default one with all the properties as arguments

struct MyStruct{
	var x:Int = 42
	var y:String = "somehting"

	init(x:int,y:String)//comes for free

}
--Set properties
--Can set let properties when they are just there.
--Can call other init methods with different arguments
--Can call super.init

What is required to do in init
--All properties must have values
--Two types of init, designated and convinience
--A designated init can only and can only call designated init of the super class
--Initializers all of your own property before you call the super init
--Call super init before you assign a value to init in your own class.

--Convinice init can only call a designated init in its own class
--Convinice init may call a designtaed init indirectly(through other convinice init)
--Must call before touching any values

--IF you do not implement any desigated inits, you get all of super classes designated inits
--If you implement no inits, you’ll inherit all of your superclass’s inits
--Any init inherited by these rules qualifies to satisfy any of the rules on the previous slide

Required init--subclasses must implement
Failable init--allowed to fail and return nil

init?(arg1:Type,...){
	//might return nil here
}

eg. UIImage


--Create Object
let x = CalculatorBrain()
let y = ComplicatedObject(arg1:42,arg2:"hello")
let z = [String]()

let button = UIButton.buttonWithType(UIButtonType.System)
let csString:String = ",".join(myArray)

***AnyObject
Special type(actualy a Protocol)
Used for compatibility

eg. var destinatioController:AnyObject
var toolbar:[AnyObject]

as arguments to function
fucn prepareForSegue(segue:UIStoryBoard,sender:AmyObject)
fucn addConstraints(constant:[AnyObject])

--How do we use it?
Use typecast keyword "as"

let calcVC = destinationViewController as CalculatorViewController
if let calcVC = destinationViewController as? ClculatorViewController{...}

as? returns an Optional

Or, if destinationVC is CalculatorViewController{...}

--Casting Arrays of AnyObject?

var toolBarItems :[AnyObject]
for item in toolBarItems {
	if let toolBarItem = item as? UIBarButtonItem{
	//do something
	}
}

or,
for toolBarItem in toolBarItems as [UIButtonItem] {//better be so, else crash
	
}
//can't do as? here

***Casting
Can cast the classes in the same inherittance tree.

***Functions
Somme Array<T> methods
+= [T] // not += T

first -> T? //note optional
last -> T? //note optional

append(T)
insert(T, atIndex:Int)
splice
removeAtIndex
removeRange
replaceRange

sort(isOrderedBefore:(T,T)->Bool) //inplace
eg. a.sort {$0<$1}

sorted //returns a sorted method , not inplace

filter 
map(transform:(T->U) ->[U])

eg. let stringified:[String] = [1,2,3].map{"\($0)"}

reduce(initial:U,combine:(U,T)->U)->U

eg. let sum:Int = [1,2,3].reduce(0){$0+$1}


***String
--String.Index
--advance(String.Index,Int)

var s = "hello"
let index = advance(s.startIndex,2) //l

s.splice("abc",index) //heabcllo
let startIndex = advance(s.startIndex,1)
let endIndex = advance(s.startIndex,6)

let substring = s[index..<endIndex] //eabcl

eg. let num = "56.25"
if let decimalRange = num.rangeOfString("."){
	let wholePart = num[num.startIndex..<decimalRange.startIndex]

}

***Type Conversion

let d:Double = 37.5
let x = Int(d) //truncates

let a= Array("abc")
let s = String(["a"],"b","c")

***Assertion
//Crash if things you want are not what you want
assert(()->Bool,"message")

eg assert(validation() != nil,"the validation func returned nil")

***Global Methods

let count =countElements(aCollection)
let sub = dropFirst(aCollection)
let sub = dropLast(aCollection)
let first = first(aCollection)
let last = last(aCollection)
let prefix = prefix(aSliecable,X:Int)
let suffix = suffix(aSliceable,X:Int)
let reversed:Array = reverse(aCollection)
let backWardString = String(reverse(s))

***Objective C Compatibility:
-Bridging
-NSString is bridged to String
-NSArray is bridged to Array<Object>
-NSDictionary is bridged to Dictionary<NSObject,AnyObject>
-Int, Float, Double, Bool to NSNumber also bridged to ctype int, float,double

-Casting from String to NSString and vice versa
Array from NSArray can be casted.

-Keys in NSDictionarty are NSObject sub classes.


***Property List
Property list is really just the definition of a term. It means an AnyObject which is known to be a collection of objects which are only of the type NSString, NSArray,NSDictionary, NSNumber,NSDate,NSData

Used to pass data around blindly. 

***NSUserDefaults
-Stores small data of property list as dictionary

setObject(AnyObject,forKey:String)
objectForKey(String)->AnyObject
arrayForKey(String)->Array<AnyObject>

-Small database
let defaults = NSUserDefaults.standardUserDefaults()
if !defaults.synchronize()

==Demo

***Views
Represents a rectangular area.(UIView)
-Hierarchical

UIWindow --The very top hierarchy. Not much used.
View can be added from code as well.
addSubView(aView:UIView)

Top Level View: view property in the ViewController
Initializers for View: 
init(frame: CGRect)
init(coder:NSCoder)

Sample Init for Views

override init(frame:CGRect){
	super.init(frame:frame)
	setup()
}
required init(coder aDecoder:NSCoder){ //required initializer
	super.init(coder:aDecoder)
	setup()
}

-awakeFromNib() When coming from storyboard

***Coordinate System Data Structures
All coordinates are CGFloat
let cfg = CGFloat(aDouble)

CGPoint
CGSize
struct CGRect{
	var origin: CGPoint
	var size: CGSize
}

let rect = CGRect(origin: aCGPoint, size: aCGSize)

-Methods
minX
midY
intersects
contains(CGPoint) -> Bool

-Origin is top left.
-Units are points not pixels
-contentScaleFactor: CGFloat number of pixels per point.

-Boundaries
var bounds : CGRect

UIView
-center var center:CGPoint in superview
-frame 	var frame: CGRect //the rect containing a UIView in its sueprviews coord system

Use frame or center to position a UIView
These are never used to draw inside a view's coord system


---Creating Views
Mostly by storyboard
Or by code: let newView = UIView(frame:myViewFrame)

eg:
let labelRect = CGRect(x:20,y:20,width:100,height:50)
let label = UILabel(frame:labelRect)
label.text = "Hello"
view.addSubView(label)


NEVER call drawRect yourself. Its called by the system.

***Custom Views
C like API
UIBezierPath

Concepts:
Get a context by UIGraphicsGetCurrentContext()
Create paths
Set drawing attributes like colors, textures, linewidths, linecaps
Stroke or fill

UIBezierPath-automatically draws in the current context
Methods for lineto, arcs
methods to stroke or fill

eg:
let path = UIBezierPath
path.moveToPoint(CGPoint(80,50))
path.addLineToPoint(CGPoint(140,150))
path.addLineToPoint(CGPoint(10,150))

Close the path
path.closePath()

Set attribbutes and stroke/fill
UIColor.greenColor().setFill() //on UIColor
UIColor.redColor().setStroke() //on UIColor
path.lineWidth = 3.0
path.fill()

--Common shapes like biunded rectangle
--addClip //only shapes in the clip will display
--containsPoint

UIColor
backgroundColor:UIColor
colors with alpha component, opaque or transparent

tell the system you are using transparency
var opaque = false

Entire View Transparent
var alpha


hidden view

--Drawing Text
let text NSAttributedString("hello")
text.drawAtPoint(aCGPoint)

NSAttributedString is not String or NSString

You can set attributes using
setAttributes
addAttributes

***Fonts
preferredFontForTextStyle(UIFontTextStyle) ->UIFont

UIFontTextStyle.Headline
UIFontTextStyle.Body
UIFontTextStyle.Footnote

--System Fonts   Dont use for user content

Drawing Images:
UIImageView
let image :UIImage? = UIImage(named: "foo")
Can be created from file System

drawAtPoint et all

Redraw on bounds change:
--var contentMode : UIViewContentMode


==Demo

***Extensions
Add methods and properties to existing classses and enums

Cant add existing methods or properties
Only computed properties

***Protocols
A way to express an API minimally
Just like a type..
Has no implementation, only declaration

Protocol declaration
Declaring that a class will conform
Actual implementation
Can be made to be conformed by only class

***Delegation
Its how we can implement blind communication between a View and its Controller

How?
a. Create a delegation protocol(defines what the view want the Controller to take care of)
b. Create a delegate property in the View whose type is the delegation protocol
c. Use delegate property in the view to get/do things it cant own or control
d. Controller declares that it implements the protocol
e. Controller sets self as the delegate of the View by setting the property in b
f. Implement the protocol in the Controller

eg. table view and table view controller

===Demo for Delegation

***Gestures
UIGestureRecognizer abstract
eg UIPanGestureRecognizer
UIPinchGestureRecognizer
UIRotationGestureRecognizer
UISwiperGestureRecognizer
UITapGestureRecognizer gives a finnger count

===Demo

***Multiple MVCs
UINAvigationController --pushed and pops MVcs off of a stack
navigationItem propert and toolbarItems property













































